    if(!areConnected(myGraph, getNodes(myGraph))) stop("Not all nodes are connected by the graph.")

    ## build the wrapper ##
    myGraph <- getGraph(x)
    ##  if(is.character(costs) && costs=="default"){
    ##         costs <- unlist(edgeWeights(myGraph))
    ##     }

    ## wrap ##
    res <- dijkstra.sp(myGraph, start=start)

    ## sp.between uses unique(x@nodes.id) ##
    ## eventually have to duplicate paths ##
    temp <- gsub(".*:","",names(res))
    res <- res[match(getNodes(x), temp)]


    ## make it a class "gPath" (output + xy coords) ##
    allNodes <- unique(unlist(lapply(res, function(e) e$path_detail)))
    res$xy <- getCoords(x)[allNodes,]
   ## attr(res,"xy") <- getCoords(x)[allNodes,]
    class(res) <- "gPath"

    return(res)
}) # end dijkstraFrom for gGraph


myPath <- dijkstraFrom(hgdp,addis)
traceback()
myPath <- dijkstraFrom(hgdpPlus,addis)
worldgraph.40k <- dropCosts(worldgraph.40k)
myPath <- dijkstraFrom(hgdpPlus,addis)
x <- hgdp
start <- addis
    myGraph <- getGraph(x)

    res <- dijkstra.sp(myGraph, start=start)

   temp <- gsub(".*:","",names(res))
    res <- res[match(getNodes(x), temp)]

    allNodes <- unique(unlist(lapply(res, function(e) e$path_detail)))

    attr(res,"xy") <- getCoords(x)[allNodes,]

    class(res) <- "gPath"

res
 myGraph <- getGraph(x)
    ##  if(is.character(costs) && costs=="default"){
    ##         costs <- unlist(edgeWeights(myGraph))
    ##     }

    ## wrap ##
    res <- dijkstra.sp(myGraph, start=start)

    ## sp.between uses unique(x@nodes.id) ##
    ## eventually have to duplicate paths ##
    temp <- gsub(".*:","",names(res))
    res <- res[match(getNodes(x), temp)]


    ## make it a class "gPath" (output + xy coords) ##

res
 myGraph <- getGraph(x)
    ##  if(is.character(costs) && costs=="default"){
    ##         costs <- unlist(edgeWeights(myGraph))
    ##     }

    ## wrap ##
    res <- dijkstra.sp(myGraph, start=start)

res
q()
n
library(geoGraph)
data(hgdp)
data(hgdpPlus)
data(worldgraph.40k)

setwd("/home/master/dev/geograph/pkg/misc/simulations/")
source("doSimul.R")



##
## COMPUTE COSTS
##

## load costs
load("/home/master/dev/geograph/pkg/misc/simulations/costsFromLm3.RData")

# myCosts <- costsFromLm3

## visualize costs
palette(heat.colors(105))
plot(worldgraph.40k, col=max(myCosts) - myCosts)


## set costs
worldgraph.40k <- setFriction(worldgraph.40k, node.costs=myCosts)
worldgraph.40k <- dropDeadEdges(worldgraph.40k, thres=2e5)

isConnected(hgdpPlus)


##
## using Addis Ababa as source
##
addis <- list(lon=38.74,lat=9.03)
addis <- closestNode(worldgraph.40k,addis) # this takes a while
doSimul(addis,hgdpPlus, ".") # result: R2=


## load costs
load("/home/master/dev/geograph/pkg/misc/simulations/costsFromLm3.RData")

# myCosts <- costsFromLm3

## visualize costs
palette(heat.colors(105))
plot(worldgraph.40k, col=myCosts)

worldgraph.40k <- setFriction(worldgraph.40k, node.costs=myCosts)
worldgraph.40k <- dropDeadEdges(worldgraph.40k, thres=2e5)

isConnected(hgdp)

addis <- list(lon=38.74,lat=9.03)
addis <- closestNode(worldgraph.40k,addis) # this takes a while
doSimul(addis,hgdp, ".") # result: R2=

search()
detach(5)
library(geoGraph)

addis <- list(lon=38.74,lat=9.03)
addis <- closestNode(worldgraph.40k,addis) # this takes a while
doSimul(addis,hgdp, ".") # result: R2=

source("doSimul.R")

doSimul(addis,hgdp, ".") # result: R2=

doSimul(addis,hgdp, ".") # result: R2=
worldgraph.40k <- dropCosts(worldgraph.40k)
doSimul(addis,hgdp, ".") # result: R2=  C-c C-c
args(as.dist.gPath)

source("doSimul.R")

doSimul(addis,hgdp, ".") # result: R2=  C-c C-c

## load costs
load("/home/master/dev/geograph/pkg/misc/simulations/costsFromLm3.RData")

#


## set costs
worldgraph.40k <- setFriction(worldgraph.40k, node.costs=myCosts)
worldgraph.40k <- dropDeadEdges(worldgraph.40k, thres=2e5)

isConnected(hgdp)

 Ababa as source
##
addis <- list(lon=38.74,lat=9.03)
addis <- closestNode(worldgraph.40k,addis) # this takes a while
doSimul(addis,hgdp, ".") # result: R2=

temp <- expand.grid(seq(-30,60,by=5), seq(-40,40,by=5))
x <- closestNode(worldgraph.40k,temp) # this takes a while

conCom <- connectedComp(getGraph(worldgraph.40k)) # get connected sets
conCom <- conCom[order(sapply(conCom,length),decreasing=TRUE)] # sort by decr. size
conCom <- conCom[[1]]
myCandidates <- intersect(x,conCom) # retained candidates
length(myCandidates)

temp <- findInLayer(getCoords(worldgraph.40k)[myCandidates,], attr="CONTINENT")
myCandidates <- row.names(temp[temp=="Africa",,drop=FALSE]) # keep nodes in Africa
plot(worldgraph.40k)
points(getCoords(worldgraph.40k)[myCandidates,])


res <- doSimul(myCandidates, hgdp, "outputs") # this can take hours (3 sim/minute)


## load costs
load("/home/master/dev/geograph/pkg/misc/simulations/costsFromLm3.RData")

# myCosts <- costsFromLm3

## visualize costs
palette(heat.colors(105))
plot(worldgraph.40k, col=myCosts)


## set costs
worldgraph.40k <- setFriction(worldgraph.40k, node.costs=myCosts)
worldgraph.40k <- dropDeadEdges(worldgraph.40k, thres=2e5)
load("/home/master/dev/geograph/pkg/misc/simulations/costsFromLm3.RData")

# myCosts <- costsFromLm3

## visualize costs
palette(heat.colors(105))
plot(worldgraph.40k, col=myCosts)


## set costs
worldgraph.40k <- setFriction(worldgraph.40k, node.costs=myCosts)
worldgraph.40k <- dropDeadEdges(worldgraph.40k, thres=2e5)

addis <- list(lon=38.74,lat=9.03)
addis <- closestNode(worldgraph.40k,addis) # this takes a while
doSimul(addis,hgdp, ".") # result: R2=

res <- doSimul(myCandidates, hgdp, "outputs") # this can take hours (3 sim/minute)

myPath
load("/home/master/dev/geograph/pkg/misc/simulations/outputs/path001.RData")
myPath
dist.phy <- as.dist.gPath(myPath, res="vec")
myPath <- dijkstraBetween(hgdpPlus,addis)
myPath <- dijkstraFrom(hgdpPlus,addis)
myPath <- dijkstraFrom(hgdpPlus,addis)
dist.phy <- as.dist.gPath(myPath, res="vec")
plot(dist.phy, 
dist.gen <- hgdpPlus@data$Genetic.Div
Hs <- hgdpPlus@data$Genetic.Div
plot(dist.phy, Hs/(1-Hs))
lmtemp <- lm(Hs/(1-Hs) ~ dist.phy)
abline(lmtemp)
hasCosts(worldgraph.40k)
myPath[[1]]
hgdp@data$Population
temp <- !hgdpPlus@data$Population %in% hgdp@data$Population
temp
points(dist.phy[temp], (Hs/(1-Hs))[temp], col="red")
lmtemp2 <- lm((Hs/(1-Hs))[temp] ~ dist.phy[temp])
abline(lmtemp2,col="red")
ancova1 <- lm(Hs/(1-Hs) ~ dist.phy * factor(temp))
summary(ancova1)
dropterm(ancova1)
dropterm(ancova1,test="F")
anova(ancova1)
plot(lmtemp2)
plot(lmtemp2)
points(dist.phy, (Hs/(1-Hs)))
points(dist.phy[temp], (Hs/(1-Hs))[temp], col="red")
plot(dist.phy, (Hs/(1-Hs)))
points(dist.phy[temp], (Hs/(1-Hs))[temp], col="red")
points(dist.phy[temp][8], (Hs/(1-Hs))[temp][8], col="red", pch="x")
temp
hgdpPlus@data$Population[temp][8]
temp[8] <- FALSE
lmtemp2 <- lm((Hs/(1-Hs))[temp] ~ dist.phy[temp])
anova(lmtemp2)
ancova1 <- lm(Hs/(1-Hs) ~ dist.phy * factor(temp))
abline(ancova1)
abline(lmtemp2)
anova(ancova1)
plot(1,col=grey(1))
plot(1,col=grey(0))
plot(1,col=grey(1))
sampfac
q()
n
