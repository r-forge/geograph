N.pole
N.pole<-1
S.pole<-2
glued.layers[2,1,1:5]<-N.pole
glued.layers[N.rows,N.cols-1,6:10]<-S.pole
edgeList<- vector("list", length=n.vertices)
names(edgeList)<-rownames(coord.centers)
library(fields)
neighbours<-matrix(ncol=2,nrow=0)
for (p in 1:10) {
for (col in 2:(n.col+1)) {
for (row in 2:(n.col+1)) {
if(!is.na(glued.layers[row,col,p])){
id<-(glued.layers[row,col,p])
id.neig<-c(glued.layers[row+1,col,p],glued.layers[row-1,col,p],glued.layers[row,col+1,p],glued.layers[row,col-1,p],glued.layers[row+1,col-1,p],glued.layers[row-1,col+1,p])
id.neig<-id.neig[!is.na(id.neig)]
this.neighbours.dist<-rdist.earth(as.matrix(coord.centers[id,]),as.matrix(coord.centers[id.neig,]),miles=F)[1,]
        edgeList[[id]] <- list(edges=id.neig, weights=this.neighbours.dist)
}
}
}
}
not.6.neighbours<-vector()
for (p in 1:10) {
for (col in 2:(n.col+1)) {
for (row in 2:(n.col+1)) {
    if(!is.na(glued.layers[row,col,p])){
 id<-(glued.layers[row,col,p])
         if (length(edgeList[[id]]$edges)!=6) {
           not.6.neighbours<-c(not.6.neighbours,id)
         }
      }
     }
   }
 }
not.6.neighbours
length(not.6.neighbours)
edgeList$V.1
edgeList$V.2
edgeList$V.3
glued.layers[1:10,1:10,1]
glued.layers[1:10,1:10,2]
glued.layers[1:10,1:10,3]
id.neig<-c(glued.layers[1,3,1],glued.layers[2,2,1],glued.layers[1,2,1],glued.layers[1,2,2],glued.layers [1,2,3])
id.neig
id.neig<-c(glued.layers[3,1,1],glued.layers[2,2,1],glued.layers[1,2,1],glued.layers[1,2,2],glued.layers [1,2,3])
id.neig
sort(id.neig)
N.id.neig<-sort(c(glued.layers[3,1,1],glued.layers[2,2,1],glued.layers[1,2,1],glued.layers[1,2,2],glued.layers [1,2,3]))
N.neighbours.dist<-rdist.earth(as.matrix(coord.centers[N.pole,]),as.matrix(coord.centers[N.id.neig,]),miles=F)[1,]
N.id.neig
N.neighbours.dist
edgeList[[N.pole]] <- list(edges=N.id.neig, weights=N.neighbours.dist)
edgeList$V.1
edgeList$V.2
edgeList$V.3
glued.layers[30:34,30:34,6]
c(glued.layers[N.rows,N.col-2,6],glued.layers[N.rows-1,N.col-1,6],glued.layers[N.rows-1,N.col,6])
c(glued.layers[N.rows,N.cols-2,6],glued.layers[N.rows-1,N.cols-1,6],glued.layers[N.rows-1,N.cols,6])
glued.layers[30:34,30:34,7]
glued.layers[30:34,30:34,8]
S.id.neig<-sort(c(glued.layers[N.rows,N.cols-2,6],glued.layers[N.rows-1,N.cols-1,6],glued.layers[N.rows-1,N.cols,6],glued.layers[N.rows-1,N.cols,7],,glued.layers[N.rows-1,N.cols,8])
)
S.id.neig<-sort(c(glued.layers[N.rows,N.cols-2,6],glued.layers[N.rows-1,N.cols-1,6],glued.layers[N.rows-1,N.cols,6],glued.layers[N.rows-1,N.cols,7],glued.layers[N.rows-1,N.cols,8])
)
S.id.neig<-sort(c(glued.layers[N.rows,N.cols-2,6],glued.layers[N.rows-1,N.cols-1,6],glued.layers[N.rows-1,N.cols,6],glued.layers[N.rows-1,N.cols,7],glued.layers[N.rows-1,N.cols,8]))
S.id.neig
S.neighbours.dist<-rdist.earth(as.matrix(coord.centers[S.pole,]),as.matrix(coord.centers[S.id.neig,]),miles=F)[1,]
edgeList[[S.pole]] <- list(edges=S.id.neig, weights=S.neighbours.dist)
not.6.neighbours<-vector()
for (p in 1:10) {
for (col in 2:(n.col+1)) {
for (row in 2:(n.col+1)) {
    if(!is.na(glued.layers[row,col,p])){
 id<-(glued.layers[row,col,p])
         if (length(edgeList[[id]]$edges)!=6) {
           not.6.neighbours<-c(not.6.neighbours,id)
         }
      }
     }
   }
 }
not.6.neighbours
length(not.6.neighbours)
edgeList$V.1
edgeList$V.2
gR <- new("graphNEL", nodes=rownames(coord.centers), edgeL=edgeList)
gR
shortest.distances
shortest.distances<-dijkstra.sp(gR)
summary(shortest.distances)
help(dijstra.sp)
help(dijkstra.sp)
shortest.distances$distances
summary(shortest.distances$distances)
edgeList[[S.pole]] <- list(edges=NULL, weights=NULL)
gR <- new("graphNEL", nodes=rownames(coord.centers), edgeL=edgeList)
shortest.distances<-dijkstra.sp(gR)
edgeList[[S.pole]] <- list(edges=S.id.neig, weights=S.neighbours.dist)
gR <- new("graphNEL", nodes=rownames(coord.centers), edgeL=edgeList)
shortest.distances<-dijkstra.sp(gR)
max(shortest.distances$distances)
help(write.object)
help(write)
save(edgeList,"edgeList.R.object")
save(edgeList,file="edgeList.R.object")
ls()
load("/home/master/dev/geograph/pkg/misc/bulk/R implementation of panels/3.Build edges /home/master/dev/geograph/pkg/misc/bulk/R implementation of panels/3.Build edges /home/master/dev/geograph/pkg/misc/bulk/R implementation of panels/3.Build edges /home/master/dev/geograph/pkg/misc/bulk/R implementation of panels/3.Build edges list/list/list/li")
dir()
load("40962 intermediate Rdata workspaces/ready to generate neighbour list.RData")
ls()
class(coord.centers)
dim(coord.centers)
head(coord.centers)
class(mod5)
load("40962 intermediate Rdata workspaces/lost.of.all.neighbours.RData")
load("40962 intermediate Rdata workspaces/list.of.all.neighbours.RData")
ls()
length(edgeList)
library(geoGraph)
head(edgeList)
x <- new("gG)
ls()
x <- new("gGgraph", coords=coords.center, )
myGraph <- new("graphNEL", edgeL=edgeList)
?graphNEL
myGraph <- new("graphNEL", nodes=edgeL=edgeList)
head(edgeList)
head(coord.centers)
myGraph <- new("graphNEL", nodes=rownames(coord.centers), edgeL=edgeList)
myGraph <- new("graphNEL", node=rownames(coord.centers), edgeL=edgeList)
myGraph <- new("graphNEL", node=rownames(coord.centers), edgeL=edgeList)
head(edgeList)
rm(list=ls())
rm(list=ls())

file.name<-"C40962.global"

##Data directory
data.dir<-c("../0.Data/")
setwd(paste(data.dir,file.name,sep=""))


library(maptools)
##################################################################################################
##Read in center coordinates

read.csv(paste(file.name,".center.coord.csv",sep=""),row.names=1)->coord.centers
coord.centers$long[coord.centers$long>180]<-coord.centers$long[coord.centers$long>180]-360

head(coord.centers)
n.vertices<-dim(coord.centers)[1]
##################################################################################################
###### Read in panels to build neighbours
as.matrix(read.csv(paste(file.name,".10.layers.csv",sep="")))->temp.panels
n.col<-dim(temp.panels)[1]
dimnames(temp.panels)[[2]]<-rep(1:n.col,10)
rect.layers<-array(NA,dim=c(n.col,n.col,10))

for (p in 1:10)
	rect.layers[,,p]<-temp.panels[,(1+(p-1)*n.col):(p*n.col)]
rm(p,temp.panels)

N.pole<-1
S.pole<-2

N.rows<-dim(rect.layers)[1]+2
N.cols<-dim(rect.layers)[2]+2
N.layers<-dim(rect.layers)[3]
glued.layers<-array(NA,dim=c(N.rows,N.cols,N.layers))

mod5<-function(x) {
	y<-x%%5
	if (y==0) {y=5}
	y
}


for (l in 1:10) {
	##fill up the core part of the layer
	glued.layers[(2:(N.rows-1)),(2:(N.cols-1)),l]<-rect.layers[,,l]
	if (l<6) {
		##1st column is the 1st row of mod5(l-1) layer
		glued.layers[3:N.rows,1,l]<-rect.layers[1,,mod5(l-1)] ##do we need last element????
		##1st row is the 1st column of mod5(l+1) layer
		glued.layers[1,2:(N.cols-1),l]<-rect.layers[,1,mod5(l+1)]
		##last column is the 1st column of mod5(l)+5
		glued.layers[2:(N.rows-1),N.cols,l]<-rect.layers[,1,mod5(l)+5]
		##last row is the 1 row of mod5(l-1)+5
		glued.layers[N.rows,2:(N.cols-1),l]<-rect.layers[1,,mod5(l-1)+5]
		##add the North Pole
		glued.layers[2,1,l]<-N.pole
		
	} else {
		##1st column is the last column of (l-5)
		glued.layers[2:(N.rows-1),1,l]<-rect.layers[,N.cols-2,(l-5)]
		##1st row is last row of (l%%5+1)
		glued.layers[1,2:(N.cols-1),l]<-rect.layers[N.rows-2,,(l%%5+1)]
		##last column is the last row of (l%%5+1+5)
		glued.layers[2:(N.rows-1),N.cols,l]<-rect.layers[N.rows-2,,(l%%5+1+5)]
		##last row is the last column of (mod5(l-1)+5)
		glued.layers[N.rows,1:(N.cols-2),l]<-rect.layers[,N.cols-2,(mod5(l-1)+5)]
		##add the south pole
		glued.layers[N.rows,N.cols-1,l]<-S.pole
	}
}

##Now add the North Pole
glued.layers[2,1,1:5]<-N.pole
glued.layers[N.rows,N.cols-1,6:10]<-S.pole
		

edgeList<- vector("list", length=n.vertices)
names(edgeList)<-rownames(coord.centers)


library(fields)
neighbours<-matrix(ncol=2,nrow=0)

file.name
for (p in 1:10) {
	for (col in 2:(n.col+1)) {
		for (row in 2:(n.col+1)) {
			if(!is.na(glued.layers[row,col,p])){
				id<-(glued.layers[row,col,p])
				id.neig<-c(glued.layers[row+1,col,p],glued.layers[row-1,col,p],glued.layers[row,col+1,p],glued.layers[row,col-1,p],glued.layers[row+1,col-1,p],glued.layers[row-1,col+1,p])
				id.neig<-id.neig[!is.na(id.neig)]
				##find distance
				this.neighbours.dist<-rdist.earth(as.matrix(coord.centers[id,]),as.matrix(coord.centers[id.neig,]),miles=F)[1,]
				##neighbours<-rbind(neighbours,cbind(rep(id,length(id.neig)),id.neig))
        edgeList[[id]] <- list(edges=id.neig, weights=this.neighbours.dist)
			}
		}
	}
}


##Now add the poles to the edge list
N.id.neig<-sort(c(glued.layers[3,1,1],glued.layers[2,2,1],glued.layers[1,2,1],glued.layers[1,2,2],glued.layers [1,2,3]))
N.neighbours.dist<-rdist.earth(as.matrix(coord.centers[N.pole,]),as.matrix(coord.centers[N.id.neig,]),miles=F)[1,]
edgeList[[N.pole]] <- list(edges=N.id.neig, weights=N.neighbours.dist)

S.id.neig<-sort(c(glued.layers[N.rows,N.cols-2,6],glued.layers[N.rows-1,N.cols-1,6],glued.layers[N.rows-1,N.cols,6],glued.layers[N.rows-1,N.cols,7],glued.layers[N.rows-1,N.cols,8]))
S.neighbours.dist<-rdist.earth(as.matrix(coord.centers[S.pole,]),as.matrix(coord.centers[S.id.neig,]),miles=F)[1,]
edgeList[[S.pole]] <- list(edges=S.id.neig, weights=S.neighbours.dist)



##Now, it time to create a graph and check that all verteces are connected
##(they will be by definition, but the test can then be repeated after changes in land characteristics)

##To install the bioconductor library to use the BOOST graph library
##source("http://bioconductor.org/biocLite.R")
##biocLite("RBGL") ## commented by Thibaut
##library(RBGL)
##gR <- new("graphNEL", nodes=rownames(coord.centers), edgeL=edgeList)
##shortest.distances<-dijkstra.sp(gR)
##max(shortest.distances$distances)
##max distance (above) should be a reasonable number (say less than 100000)


##Save the edgeList as an R object
save(edgeList,file=paste(file.name,".edgeList.R.object",sep=""))
##Create an empty file to remove edges
write.csv(matrix(ncol=2,nrow=0,dimnames=list(NULL,c("vertex1","vertex2"))),file=paste(file.name,".removed.edges.csv",sep=""))


head(edgeList)
save.image()
q()
y
