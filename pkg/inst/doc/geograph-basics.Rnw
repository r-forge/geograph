\documentclass{article}
% \VignettePackage{geoGraph}
% \VignetteIndexEntry{geoGraph: exploratory analyses for the phylogenetic comparative method}

\usepackage{graphicx}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{array}
\usepackage{color}

\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\newcommand{\code}[1]{{{\tt #1}}}
\title{\code{geoGraph}: implementing geographic graphs for large-scale spatial modelling}
\author{Thibaut Jombart, Andrea Manica, Fran\c{c}ois Balloux}
\date{\today}




\sloppy
\hyphenpenalty 10000


\begin{document}



\definecolor{Soutput}{rgb}{0,0,0.56}
\definecolor{Sinput}{rgb}{0.56,0,0}
\DefineVerbatimEnvironment{Sinput}{Verbatim}
{formatcom={\color{Sinput}},fontsize=\footnotesize, baselinestretch=0.75}
\DefineVerbatimEnvironment{Soutput}{Verbatim}
{formatcom={\color{Soutput}},fontsize=\footnotesize, baselinestretch=0.75}

\color{black}

\maketitle
\tableofcontents



%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%

\SweaveOpts{prefix.string = figs/geoGraph, fig = FALSE, eps = FALSE, pdf = TRUE, width = 6, height = 6}


This document describes the \code{geoGraph} package for the R software.
\code{geoGraph} aims at implementing graph approaches for geographic data.
In \code{geoGraph}, a given geographic area is modelled by a fine regular grid, where each vertice
has a set of spatial coordinates and a set of attributes, which can be for instance habitat
descriptors, or the presence/abundance of a given species.
'Travelling' within the geographic area can then be easily modelled as moving between connected vertices.
The costs of moving from one vertex to another can be defined according to attribute values, which
allows for instance to define \emph{frictions} based on habitat.
\\

\code{geoGraph} harnesses the full power of graph algorithms implemented in R by the \code{graph}
and the \code{RBGL} (R Boost Graph Library) packages.
In particular, RBGL is an interface between R and the impressive \emph{Boost Graph Library} in C++,
proposing a wide range of algorithms with fast and efficient implementation.
Therefore, once we have defined frictions for an entire geographic area, we can easily, for instance, find the least
costs path from one node to another, or find the most parsimonious way of connecting a set of locations.
\\

Once all data are set, calling upon RBGL routines is generally straightforward.
However, interfacing spatial data and graphs can be a complicated task.
The purpose of \code{geoGraph} is to simplify these 'preliminary' steps.
This is achieved by defining new classes of objects which are essentially geo-referenced graphs
with attributes (\code{gGraph} objects) and interfaced spatial data (\code{gData} objects).
In this vignette, we show how to install \code{geoGraph}, show how to construct and handle
\code{gGraph}/\code{gData} objects, and illustrate some basic features of graph algorithms.









%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{First steps}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%
\subsection{Installing the package}
%%%%%%%%%%%%%%%%%%%%%

What is tricky here is that a vignette is basically available once the package
is installed.  Assuming you got this document before installing the package, here are some clues
about installing \code{geoGraph}.  \\

First of all, \code{geoGraph} depends on the packages \code{methods} (base package), \code{graph} (on Bioconductor),
and \code{RBGL} (on Bioconductor).
These dependencies are mandatory, that is, you actually need to
have these packages installed before using \code{geoGraph}.
Also, it is better to make sure you are using the latest versions of these packages.
While the \code{methods} package is part of the basic R release, \code{graph} and \code{RBGL} are
no longer developped on CRAN, although some outdated versions still persist.
To make sure you are using the right version, use the command \code{installDep.geoGraph()} while
connected on the internet.
Do NOT use \code{install.packages}, or related functionalities from the interactive menus.
In all cases, the latest version of \code{geoGraph} can be found from \url{http://r-forge.r-project.org/R/...}.  \\

When loading the package, dependencies are also loaded:
<<load>>=
library(geoGraph)
search()
@

The package is now ready to use.




%%%%%%%%%%%%%%%%%%%%%
\subsection{Data representation}
%%%%%%%%%%%%%%%%%%%%%
Two types of objects are used in \code{geoGraph}: \code{gGraph}, and \code{gData} objects.
Both objects are defined as formal (S4) classes and often have methods for similar generic function
(\textit{e.g.}, getNodes is defined for both objects).
Essentially, \code{gGraph} objects contain underlying layers of informations, including a spatial
grid and possibly node attributes, and covering the area of interest.
\code{gData} are sets of locations -- like sampled sites, for instance -- which have been interfaced
to a \code{gGraph} object, to allow further manipulations such as finding paths on the grid between
pairs of locations.




%%%%%%%%%%%%%%%%%%%%%
\subsubsection{gGraph objects}
%%%%%%%%%%%%%%%%%%%%%
The content of the formal class \code{gGraph} can be obtained using:
<<>>=
getClass("gGraph")
@
and a new empty object can be obtained using the constructor:
<<>>=
new("gGraph")
@

The documentation \code{?gGraph} explains the basics about the object's content.
In a nutshell, these objects are spatial grids with nodes and segments connecting neighbouring
nodes, and additional informations on the nodes or on the graph itself.
\code{coords} is a matrix of longitudes and latitudes of the nodes.
\code{nodes.attr} is a data.frame storing attributes of the nodes, such as habitat descriptors; each
row corresponds to a node of the grid, each column being a variable.
\code{meta} is a list containing miscellanous informations on the graph itself.
There is no contraint in the components of the list, but some components will be recognised by
certain functions.
For instance, you can specify plotting rules for representing a given node attribute by a given
color by defining a component \code{\$colors}.
Similarly, you can associate costs to a given node attribute by defining a component \code{\$costs}.
An example of this can be found in already existing \code{gGraph} objects.
For instance, \code{worldgraph.10k} is a graph of the world with approximately 10,000 nodes, and
only on-land connectivity (\textit{i.e.} no travelling on the seas).
<<>>=
data(worldgraph.10k)
worldgraph.10k
worldgraph.10k@meta
@
Lastly, the \code{graph} component is a \code{graphNEL} object, which is the standard class for
graphs in the \code{graph} and \code{RBGL} packages.
This object contains all information on the connections between nodes, and the weights (costs) of
these connections.
\\

Four main \code{gGraph} are provided with \code{geoGraph}: \code{rawgraph.10k}, \code{rawgraph.40k},
\code{worldgraph.10k}, and \code{worldgraph.40k}.
These datasets are available using the command \code{data}.
All these datasets are evenly spaced grids covering the entire earth, with some basic habitats
descriptors provided as node attributes.
The difference between rawgraphs and worldgraphs is that the first are entirely connected, while in the
second connections occur only on land.
Numbers `10k' and `40k' indicate that the grids are formed of roughly 10,000 and 40,000 nodes.
For illustrative purposes, we shall use the 10k grids, since they are less heavy to handle.
For most large-scale applications, the 40k versions should provide sufficient resolution.
New \code{gGraph} can be constructed using the constructor (\code{new(...)}), but this topic is not
documented in this vignette.




%%%%%%%%%%%%%%%%%%%%%
\subsubsection{gData objects}
%%%%%%%%%%%%%%%%%%%%%
\code{gData} are essentially sets of locations that have been interfaced with a \code{gGraph} object.
During this operation, each location is assigned to the closest node on the grid of the
\code{gGraph}, then allowing for travelling between locations on the grid.
Then, for instance, it is possible to find the shortest path between two locations through some
types of habitats, or using ecological costs.
\\

Like for \code{gGraph}, the content of the formal class \code{gData} can be obtained using:
<<>>=
getClass("gData")
@
and a new empty object can be obtained using the constructor:
<<>>=
new("gData")
@
As before, the description of the content of these objects can be found in the documentation (\code{?gData}).
\code{coords} is a matrix of xy (longitude/latitude) coordinates in which each row is a location.
\code{nodes.id} is vector of characters giving the name of the nodes matching the locations; this is
defined automatically when creating a new \code{gData}, or using the function \code{closestNode}.
\code{data} is a slot storing data associated to the locations; it can be anything, but a data.frame
should cover most requirements for storing data.
Note that this object should be subsettable (i.e. the \code{[} operator should be defined), so that data can be subsetted when subsetting the \code{gData} object.
Lastly, the slot \code{gGraph.name} contains the name of the \code{gGraph} object to which the
\code{gData} has been interfaced.
\\


Contrary to \code{gGraph} objects, \code{gData} objects will frequently be constructed.
In the next sections, we shall illustrate how we can build and use \code{gData} objects from a set
of locations.







%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{Using \code{geoGraph}}
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
An overview of the material implemented in the package is summarized the package's manpage, accessible
via:
<<eval=FALSE>>=
?geoGraph
@
The html version of this manpage may be preferred to browse more easily the content
of \code{geoGraph}; it is accessible by typing:
<<eval=FALSE>>=
help("geoGraph", package="geoGraph", html=TRUE)
@
To revert help back to text mode, simply type:
<<eval=FALSE>>=
options(htmlhelp = FALSE)
@

In the following, we go through various tasks that can be achieve using \code{geoGraph}.







%%%%%%%%%%%%%%%%%%%%%
\subsection{Importing geographic data}
%%%%%%%%%%%%%%%%%%%%%
Geographic data consist of a set of locations, possibly accompanied by additional information.
For instance, one may want to study the migrations amongst a set of biological populations with known
geographic coordinates.
In \code{geoGraph}, geographic data are stored in \code{gData} objects.
These objects match locations to the closest nodes on a grid (a \code{gGraph} object), and store
additional data if needed.
\\


As a toy example, let us consider three locations: Bordeaux (France), London (UK), Malaga (Spain), and Zagreb (Croatia).
Since we will be working with a crude grid (10,000 nodes), locations need not be exact.
We enter the longitudes and latitudes (in this order, that is, xy coordinates) of these cities in
decimal degrees, as well as approximate population sizes:
<<cities>>=
Bordeaux <- c(-1,45)
London <- c(0,51)
Malaga <- c(-4,37)
Zagreb <- c(16,46)
cities.dat <- rbind.data.frame(Bordeaux, London, Malaga, Zagreb)
colnames(cities.dat) <- c("lon","lat")
cities.dat$pop <- c(1e6, 13e6, 5e5, 1.2e6)
row.names(cities.dat) <- c("Bordeaux","London","Malaga","Zagreb")
cities.dat
@
We load a \code{gGraph} object which contains the grid supporting the data:
<<fig=TRUE>>=
data(worldgraph.10k)
worldgraph.10k
plot(worldgraph.10k)
@

\noindent (we could use \code{worldgraph.40k} for a better resolution).
On this figure, each node is represented with a color depending on the habitat type, either 'sea'
(blue) or 'land' (green).
We are going to interface the cities data with this grid; to do so, we create a \code{gData} object using
\code{new} (see \code{?gData} object):
<<cities, fig=TRUE>>=
cities <- new("gData", coords=cities.dat[,1:2], data=cities.dat[,3,drop=FALSE], gGraph.name="worldgraph.10k")
cities
plot(cities, type="both")
plotEdges(worldgraph.10k)
@

\noindent This figure illustrates the matching of original locations (crosses) to nodes of the grid
(red circles).
As we can see, an issue occured for Bordeaux, which has been assigned to a node in the sea (in blue).
Locations can be re-assigned to nodes with restrictions for some node attribute values using
\code{closestNode}; for instance, here we constrain matching nodes to have an \code{habitat} value
(defined as node attribute in \code{worldgraph.10k}) equalling \code{land} (green points):
<<closeNode, fig=TRUE>>=
cities <- closestNode(cities, attr.name="habitat", attr.value="land")
plot(cities, type="both")
plotEdges(worldgraph.10k)
@

\noindent Now, all cities have been assigned to a node on the grid (again, better accuracy will be
gained on 40k or finer grids - we use 10k for illustrative purposes only).
Content of \code{cities} can be accessed via various accessors (see \code{?gData}).
For instance, we can retrieve original locations, assigned nodes, and additional data using:
<<>>=
getCoords(cities)
getNodes(cities)
getData(cities)
@
We can also get the exact coordinates of the matching nodes using:
<<>>=
getCoords(worldgraph.10k[getNodes(cities)])
@
More interestingly, we can now retrieve all the geographic information contained in the underlying
grid (i.e., \code{gGraph} object) as node attributes:
<<>>=
getNodesAttr(cities)
@
In this example, the information stored in \code{worldgraph.10k} is rather crude: it only
distinguishes land from sea.
However, more complex habitat information could be incorporated, for instance from GIS shapefiles
(see dedicated section below).







%%%%%%%%%%%%%%%%
\subsection{Visualizing data}
%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%
\subsection{Editing graphs}
%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%%
\subsection{Extracting information from GIS shapefiles}
%%%%%%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%%
\subsection{Finding least-cost paths}
%%%%%%%%%%%%%%%%%%%%%




\end{document}
